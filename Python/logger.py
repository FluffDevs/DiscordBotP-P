"""Logger simple qui écrit des fichiers horaires et peut forwarder vers Telegram.
"""
import os
import pathlib
import json
from datetime import datetime


# Place les fichiers de logs dans le dossier `Python/logs` pour garder les artefacts
# liés au port Python à l'intérieur du répertoire `Python/`.
BASE_DIR = pathlib.Path(__file__).resolve().parent
LOG_DIR = BASE_DIR / 'logs'
LOG_DIR.mkdir(parents=True, exist_ok=True)


def _current_log_file():
    now = datetime.utcnow()
    return LOG_DIR / f"app-{now.year}-{now.month:02d}-{now.day:02d}-{now.hour:02d}.log"


class Logger:
    def __init__(self):
        self.level = os.getenv('LOG_LEVEL', 'debug').lower()

    def _write(self, level, msg, no_telegram=False):
        ts = datetime.utcnow().isoformat()
        line = f"[{ts}] [{level.upper()}] {msg}\n"
        try:
            f = _current_log_file()
            if not f.exists() or f.stat().st_size == 0:
                f.write_text('/* Logs generated by Python port */\n\n', encoding='utf8')
            with f.open('a', encoding='utf8') as fh:
                fh.write(line)
        except Exception:
            pass
        # print to console
        if level == 'error':
            print(line.strip(), file=os.sys.stderr)
        else:
            print(line.strip())
        # forward to telegram if requested and enabled
        try:
            if not no_telegram and os.getenv('TELEGRAM_ENABLED', '').lower() == 'true':
                # dynamic import to avoid circular imports at startup
                from telegram_bridge import TelegramBridge
                tb = TelegramBridge()
                tb.enqueue_log(line)
        except Exception:
            pass

    def debug(self, msg, **kwargs):
        if self.level in ('debug',):
            self._write('debug', msg, **kwargs)

    def info(self, msg, **kwargs):
        if self.level in ('debug', 'info'):
            self._write('info', msg, **kwargs)

    def warn(self, msg, **kwargs):
        if self.level in ('debug', 'info', 'warn'):
            self._write('warn', msg, **kwargs)

    def error(self, msg, **kwargs):
        self._write('error', msg, **kwargs)


def command_invocation(details):
    try:
        if isinstance(details, str):
            text = details
        else:
            time = datetime.utcnow().isoformat()
            user = details.get('userTag') or details.get('userId') or 'unknown'
            guild = details.get('guildId') or 'DM'
            channel = details.get('channelId') or 'unknown'
            cmd = details.get('commandName') or details.get('command') or 'unknown'
            opts = details.get('options') or details.get('args') or ''
            text = f"CMD {time}\nCommand: {cmd}\nUser: {user}\nGuild: {guild}\nChannel: {channel}\nOptions: {opts}"
        Logger().info(text, no_telegram=True)
        if os.getenv('TELEGRAM_ENABLED', '').lower() == 'true':
            from telegram_bridge import TelegramBridge
            tb = TelegramBridge()
            tb.enqueue_log(text)
    except Exception:
        pass


__all__ = ['Logger', 'command_invocation']
